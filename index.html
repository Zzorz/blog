<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.121.1"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Misc</title>
<meta name=description content><meta name=author content><link rel=canonical href=https://blog.razyang.com/><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.razyang.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.razyang.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.razyang.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.razyang.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.razyang.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://blog.razyang.com/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Misc"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://blog.razyang.com/"><meta name=twitter:card content="summary"><meta name=twitter:title content="Misc"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Misc","url":"https://blog.razyang.com/","description":"","thumbnailUrl":"https://blog.razyang.com/favicon.ico","sameAs":[]}</script></head><body class="list dark" id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.razyang.com/ accesskey=h title="Misc (Alt + H)">Misc</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.razyang.com/archives title=archives><span>archives</span></a></li><li><a href=https://blog.razyang.com/tags title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class="first-entry home-info"><header class=entry-header><h1>Hi</h1></header><div class=entry-content>Be Easy</div><footer class=entry-footer><div class=social-icons></div></footer></article><article class=post-entry><header class=entry-header><h2>Nix and Content Address</h2></header><div class=entry-content><p>Nix目前的构建和发布模型 derivation outputs and output paths Nix软件构建以Derivation为核心，Derivation有以下核心属性：
Derivation表示了软件的构建过程； Derivation可以依赖其他Derivation； Derivation执行后具有副作用，会在/nix/store下生成路径为xxx-name.drv的文件，其中xxx为该Derivation的唯一标识符，在任何电脑中都一致； xxx-name.drv可以被进一步构建成产物，并且产物的路径存储在xxx-name.drv中，在构建前就可以知道，此处我们称为outPath； outPath路径中也存在唯一标识，同一个Derrvation产生的.drv文件中的outPath一定相同； 由于构建前就知道产物路径，引用某个derivation时，只要检查其中存储的outPath存不存在，就可以判定需不需要重复编译； 不同机器可以通过共享outPath来共享构建缓存； 这里存在两个目录，一个是.drv的目录，一个是outPath的目录，两者的路径中都有唯一标识符，且路径都根据Derivation的参数计算得来，outPath存储在.drv中。
构建过程 nix包管理的软件构建过程用伪码表示大致如下:
derivation = getDerivationFrom(nixpkgs, package_name) drv = derivatoin() # 此处存在副作用，derivation函数调用后会生成.drv文件 if checkOutPathExist(drv.outPath): pass # 如果产物目录已经存在，就不用重复构建了 else: drv.build() # drv.build()会将软件构建后放到drv.outPath中 binary cache引入后:
derivation = getDerivationFrom(nixpkgs, package_name) drv = derivatoin() if checkOutPathExist(drv.outPath): pass else: if fetchOutPathFromBinaryCache(drv.outPath): pass # 尝试从BinaryCache服务器中下载对应的包，放到outPath中 else: drv.build() Input-Address Model 总体来说，上面我们描述的目前Nix的做法是将软件构建软件的过程（包括输入）抽象为一个哈希值，这个唯一哈希值可以代表软件的某个特定状态，然后用这个哈希值来索引构建后的软件。
在构建过程当中，任何输入的改变必然会导致输出的路径发生变化： 过度重复构建 你可能已经意识到了一些不对，在正常的软件构建过程当中，输入的改变不一定会导致输出不同，比如说代码路径下面增加了一些文档，或者说构建流程发生了改变。
然而在Nix目前的构建模型中，输入的任何变化都会导致输出路径的变化，但现实当中这样往往会导致一些不好的副作用。
例如go语言的源码中使用perl来做代码单元测试，原则上来说，使用什么版本的perl做单元测试，或者是否做单元测试，都不会改变构建产物。我们可以认为，源码中不是所有改动都会影响产物。但在nix中，如果perl包发生了改变，而go又依赖perl做单元测试，那么go的产物路径就会发生变化，进而需要重新编译。再进一步，所有依赖go的包也需要重新编译，导致了很多没有必要的重复编译。
Content-Address Model 解决上述问题的方式思路也很简单，就是使用content address的方式来确定构建缓存的实际目录。
所谓content address，与input address相对。在input address的模型中，用于索引value的key与value内容无关； 但在content address的模型中，用于索引value的key是根据value的内容计算得来。content address最简单的例子就是使用文件的哈希值来索引文件，给定文件的哈希值，返回文件内容； 而input address典型例子就是给定文件的文件名，返回文件的内容；...</p></div><footer class=entry-footer><span title='2023-12-08 16:34:44 +0800 +0800'>December 8, 2023</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to Nix and Content Address" href=https://blog.razyang.com/posts/nix-and-content-address/></a></article><article class=post-entry><header class=entry-header><h2>Way to Nix 1</h2></header><div class=entry-content><p>最近学习了一些Nix相关的东西，把家里大多数机器都切到了nixos上，感觉很不错。但是由于nix文档比较差，写自己配置的时候，很多时候需要看代码，或者抄别人的配置一点点凑，过程当中遇到了不少问题。也学习了不少Nix的基本概念，于是记录一下相关的概念和技术以免忘记。
前阵子看过NickCao的前些年的一个视频，非常有条例的介绍了一些nix的基本概念，有兴趣可以去看一下：【金枪鱼之夜：Nix - 从构建系统到配置管理-哔哩哔哩】
Nix as a build systems 构建系统一般就是指从源码生成产物的一套工具生态集合，就拿Makefile举例，几乎所有的构建过程都可以描述成如下形式的嵌套结构：
构建目标: 构建原料 构建过程 围绕着gnu make，有一套完整的，有着悠久历史的构建系统，如GNU Autoconf，Cmake等，许多现代语言也包含了自己的构建系统，如rust的cargo，go的build，js的npm等等。也会有许多项目选择多种构建系统嵌套，如Cmake生成makefile调用Cargo来进行项目构建。
Derivation 也许nix里最重要的概念就是Derivation了，它与nix中的很多概念相互关联，并作为纽带。可以说理解了Derivation，至少就理解了Nix的半壁江山。
首先， derivition是nix中的一个内置函数,代码实现位于(https://github.com/NixOS/nix/blob/188c803ddb5e63b243ddb84eba9b70e45475b7ea/src/libexpr/primops/derivation.nix#L2)，实际调用的是内部C++函数prim_derivationStrict:
nix-repl> derivation «lambda @ /builtin/derivation.nix:5:1» 与其他构建系统类似，derivation包含了构建原料，构建目标以及构建过程，调用这个函数必须有name、system以及builder三个必选参数，其他可选参数可参考Nix Reference Manual:
nix-repl> derivation {name = "target_name";system="x86_64-linux"; builder="builder_binary";} «derivation /nix/store/6z9jj5khn7j3xi2fv8fibpzj6gnq4iz4-target_name.drv» 值得注意的是，derivation函数存在一个副作用，即在/nix/store/目录下生成一个以.drv为后缀的文件，并且文件名中包含了一个类似哈希的字符串，保证路径的唯一性。derivation有如下属性:
同样参数的derivation函数调用后生成的文件，路径一定是一样的（在哈希算法的保证下，可以假定不同参数调用derivation产生的drv文件路径一定是不同的） derivation中包含的所有参数必须为字面量，或预先可以确定哈希值的固定内容（Fixed-Output Derivations） derivation可以互相依赖，一个derivation可以依赖另外一个derivation derivation可以被执行，类似Makefile一样可以被构建 derivation会被在隔离的环境执行，其中没有类似/bin/bash之类可以预先假定存在的路径，能且只能通过derivation依赖的方式在构建过程当中引入其他软件 derivation执行后会产生两个关键参数，out.out以及out.outPath，一个存储了drv的路径，一个存储了构建产物的路径 nix-repl> d = derivation {name = "target_name";system="x86_64-linux"; builder="builder_binary";} nix-repl> d.out.out «derivation /nix/store/6z9jj5khn7j3xi2fv8fibpzj6gnq4iz4-target_name.drv» nix-repl> d.out.outPath "/nix/store/pd5l9rzb613v5lv4c6q2m0c81zd9w3l6-target_name" nix-repl> d.out.out == d true nix-repl> d.out == d true 以上属性组合的结果，使得nix构建系统存在如下特性：...</p></div><footer class=entry-footer><span title='2023-12-01 11:56:15 +0800 +0800'>December 1, 2023</span>&nbsp;·&nbsp;2 min</footer><a class=entry-link aria-label="post link to Way to Nix 1" href=https://blog.razyang.com/posts/way-to-nix-1/></a></article><article class=post-entry><header class=entry-header><h2>叛逃</h2></header><div class=entry-content><p>所谓叛逃 仔细想一想，自从上大学开始，我用linux做为日常工作和学习的系统也有将近六年了。 这六年来，常见的Linux发行版基本都装了个遍，常见的桌面环境和窗口管理器也基本用了个遍。 不过随着时间流逝，我逐渐发现，桌面环境折腾无数遍，其实实际在用的图形界面软件只有三个：emacs、chrome、alacritty。
更抽象一点的话，其实就是一个编辑器，一个浏览器还有一个终端模拟器。其他软件使用频率都非常低，最近两年内，我逐渐发现自己打开文件管理器的频率也越来越低，以至于文件管理器对于我日常的电脑使用来说，也成为了一个没有必要的软件。
铺垫了这么多，其实我就是想说，爷叛逃了，到MacOS。
目的地 其实也没啥道理，最近想买一个笔记本，看了一圈。intel 11代摆大烂，12代功耗爆炸；AMD 6000系的笔记本，续航稍微好一些，但GPU硬件设计有问题。仔细想了一想，苹果的笔记本成了这两年唯一没重大问题，没开过什么倒车的设备了。
所以，Macbook Air m2 16+512，请： 基本配置 终端应用 brew install p7zip starship rustup-init tmux go coreutils grep startship bottom zoxide fzf ripgrep shellcheck starship hugo fd 7z pandoc neofetch 大概先装这么多吧，zsh配置后续再迁移过来
GUI 写这篇文章的时候突然恍然大悟，原来我能在这台电脑上装qq和微信，突然间一股惆怅的情绪涌上心头
其实也没啥好装的，浏览器暂时看看safari表现怎么样了，之后如果不成的话再装chrome。
文本编辑器的话，还是当之无愧的emacs。虽然在macos上的这个版本没有native compile，但是感觉响应速度没有什么明显区别：
brew install --cask emacs</p></div><footer class=entry-footer><span title='2022-08-07 12:52:43 +0800 +0800'>August 7, 2022</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to 叛逃" href=https://blog.razyang.com/posts/defection/></a></article><article class=post-entry><header class=entry-header><h2>Template Post</h2></header><div class=entry-content><p>segment segment segment segment Text style This text is in italics. And so is this text.
This text is in bold. And so is this text.
This text is in both. As is this! And this!
Paragraph This is a paragraph. I’m typing in a paragraph isn’t this fun?
Now I’m in paragraph 2. I’m still in paragraph 2 too!
I’m in paragraph three!
This is a block quote. You can either manually wrap your lines and put a > before every line or you can let your lines get really long and wrap on their own....</p></div><footer class=entry-footer><span title='2022-08-04 11:30:51 +0800 +0800'>August 4, 2022</span>&nbsp;·&nbsp;1 min</footer><a class=entry-link aria-label="post link to Template Post" href=https://blog.razyang.com/posts/template-post/></a></article></main><footer class=footer><span>&copy; 2023 <a href=https://blog.razyang.com/>Misc</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>